package com.wl.study._final;

/**
 * 这个用例主要是为了说明使用final修饰变量后，可以避免出现指令重排序的问题
 * >>>写final域的重排序规则：禁止把final域的写重排序到构造函数之外，这个规则的实现包含两方面：
 * 1，JVM禁止编译器把final域的写重排序到构造函数之外
 * 2，编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障
 * 结合下面的示例看一下：
 * 先假设读线程B读对象引用与读对象成员域之间没有重排序。线程A调用write方法后，构造函数开始执行：
 * 1，构造一个FinalTest类型的对象2，将这个对象的引用赋值给引用变量obj.
 * 会存在这样一种情形：写普通域(也就是i)被编译器重排序到了构造函数之外，而读线程B则会读取到还未在构造器中赋值
 * 的i(因为被重排序到构造器之外了)；但在读取j时因为不会被重排序，它的初始化被限制在了构造器内，所以读取j的值
 * 不会存在问题
 * 写 final 域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，
 * 而普通域不具有这个保障
 *
 * >>>读final域的重排序规则：在一个线程中，初次读对象引用与初次读该对象包含的final域(这两个操作存在着依赖
 * 关系)，JVM禁止重排序这两个操作，编译器会在读final域操作前面加一个LoadLoad屏障
 * 还是结合下面的示例看一下：
 * 先假设写线程A调用构造器时没有重排序。线程B调用了read()方法：
 * 1，初次读取引用变量obj
 * 2，初次读引用变量 obj 指向对象的普通域 j。
 * 3，初次读引用变量 obj 指向对象的final 域 i。
 * 会存在这样一种情形：读取对象的普通域的操作被处理器重排序到读对象引用之前，因为该域还没被写线程写入而出现了
 * 错误的读取操作；而读取final域的重排序规则会把读对象final域的操作限定在读对象引用之后，此时final域已经
 * 被 A 线程初始化过了，这是一个正确的读取操作。读 final 域的重排序规则可以确保：在读一个对象的 final域
 * 之前，一定会先读包含这个 final 域的对象的引用
 */
public class FinalTest {
    int i;
    final int j;
    static FinalTest test;
    public FinalTest(){
        i=1;
        j=2;
    }
    public static void write(){//写线程A执行
        test = new FinalTest();
    }
    public static void read(){//读线程B执行
        FinalTest t = test;////读对象引用
        int a = t.i;//读普通域
        int b = t.j;//读final域
    }

}

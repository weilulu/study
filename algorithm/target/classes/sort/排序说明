[希尔排序]
是在插入排序的基础上演变而来的，插入排序总是在进行相邻元素间移动，而希尔排序指定一定的间隔数h，
将待排序数分隔为若干子序列，在若干子序列里进行插入排序（以h的跨度进行交换，h会随着每次循环变小），
当所有子序列基本有序时再进行一次整体的插入排序（h会变成1，就相当于普通的插入排序了）

注：
１.插入排序在数据量较少、待排序数基本有序(只用比较不用交换)的情况下效率很高。
希尔排序排序就是创造了这两个条件
２.希尔排序时间复杂度：O(n的3分之2次方)

[堆排序]
堆排序是选择排序的升级
将待排序的序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根元素。将它移走（将其与堆数组末尾元素进行交换，
末尾元素就是最大小值），然后将剩下n-1个序列重新构造为一个堆然后进行交换，最后就得到一个有序序列了。

堆排序时间复杂度：最好最坏平均都是O(nlogN)

[并归排序]
利用并归的思想实现的排序方法，假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两并归，
得到[n/2]个长度为2或1有的序子序列，重复下去直到得到一个长度为n的有序序列
另一种说明：采用分治思想，并归分为两大部分，先分后合。先将待排序序列分为多个子序列直到不能再细分，然后转入合并的操作，在合并过程中确保
相临子序列有序，直到最后合并成一个最大的序列。
时间复杂度：最好最坏平均都是O(nlogN)

[快速排序]
快速排序是冒泡排序的升级
通过一趟排序将待排序记录分成独立的两部分，其中一部分的关键字均比另一部分记录的关键字小，分别对这两部分记录继续进行排序，
以达到整个序列有序的目的.这个算法关键点是找一个点将记录分成两部分
时间复杂度：最好与平均是O(nlogN)，最坏是n的平方

二叉树->二叉查找树->AVL/红黑树

二叉树：每个节点最多有两个子树的树结构
二叉查找树：一种特殊的二叉树，左节点比父节点小，右节点比父节点大，高度(理想高度为LogN)决定查询效率
如果二叉查询树都在一边子节点插入，高度会特别大，这样查询效率会降低，于是出现了AVL与红黑树.AVL插入与删除性能特别差，
所以平时一般多用红黑树
红黑树的一些规则保证了自平衡，从根到叶子节点的最长路径不会超过最短路径的２倍

满二叉树：一种特殊的二叉树，如果所有分支结点都存在左子树与右子树，且所有的叶子都在同一层上，这样的二叉树叫做满二叉树。
　　　　　注意：这里并没有要求满二叉树左右子节点数的大小是否有序

InnoDB为什么使用B+树实现？
不用数组的原因：
有序数组通过二分查找时间复杂度为O(logN),但插入和删除效率低
不用Hash表的原因：
插入、查询、删除基本都是O(1)，但出现碰撞后时间复杂度会上升，主要是不能进行范围查询
不用二叉查找树：
二叉查找树的高度会随着节点增加而增加，数据量大的时候，根节点可能会在内存里但其它节点数据需要存在磁盘里，每查找一层都需要读取一次磁盘，
代价相当大，且二叉树一个节点只能存一个数据，很浪费空间
B+树：
高扇出的特点使得一个节点(一个节点为一页)可以存储多个数据，且高度一般为2-4，一次查找只需要1-3次磁盘io.另外，叶子节点不存具体数据，
可以尽可能多的将节点放在内存里
扇出：假设一个节点有两个key，17,35，划分了三个区间（-无穷,17) p1,[17, 35) p2, [35, +无穷] p3三个区间，则称扇出为3
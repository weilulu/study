我们有 1 千万个整数，整数的范围在 1 到 1 亿之间。如何快速查找某个整数是否在这 1 千万个整数中呢？

可以使用一种特殊的散列表：位图，申请大小为１个亿、数据类型为bool的数组，并将这1 千万个整数作为数组下标，将
对应的值设置为true,当我们查询整数k是否在这 1 千万个整数中的时候，只需要将对应的数组值array[k]取出来看是
不是true，是说明在，不是就不在

为了减少内存的消耗，于是出现了布隆过滤器

接着考虑这样一种场景：
数据个数是 1 千万，数据的范围是 1 到 10 亿
布隆过滤器的做法是仍然使用一个１亿个二进制大小的位图，然后通过哈希函数对数据进行处理，让它落在１到１亿之间，
为了降低哈希冲突的可能性，我们使用Ｋ个哈希函数对同一个数据进行运算，得到Ｋ个不同的数值，记为Ｘ１、Ｘ２、……
Ｘk，我们将这Ｋ个值作为位图的下标，对应的bitmap[X1]、bitmap[X2]...bitmap[Xk]都设为true.
当我们要查找指定的数是否存在其中时，我们同样使用Ｋ个hash函数对其进行运算，分别得到Y1、Y2...Yk.
然后看这k个哈希值,如果都为true则说明这个数字存在；如果其中有一个为false则说明不存在

经过一个哈希函数处理之后，可能会产生相同的哈希值。但是经过 K 个哈希函数处理之后，K 个哈希值都相同的概率就非常低了
这解释了为什么要使用多个哈希函数进行运算
需要注意的是：如果某个数字经过布隆过滤器判断不存在，那说明这个数字真的不存在，不会发生误判；
如果某个数字经过布隆过滤器判断存在，这个时候才会有可能误判，有可能并不存在